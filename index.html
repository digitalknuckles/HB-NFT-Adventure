<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Harvesting Click-to-Move Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.85.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; margin: auto; }
    </style>
</head>
<body>

<script>
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: { default: 'arcade', arcade: { debug: false }},
    scene: { preload, create, update }
};

new Phaser.Game(config);

let workers = [];
let resources = [];
let selectedWorkers = [];
let bucket;

const RESOURCE_TYPES = [
    { key: 'tree', value: 300, interval: 500 },
    { key: 'rock', value: 500, interval: 900 },
    { key: 'crystal', value: 800, interval: 1400 }
];

function preload() {
    this.load.image('tree', 'assets/resource.png');
    this.load.image('rock', 'assets/rock.png');
    this.load.image('crystal', 'assets/crystal.png');
    this.load.image('bucket', 'assets/bucket.png');
    this.load.image('select', 'assets/select.png');
    this.load.spritesheet('character','assets/character.png',{ frameWidth:32, frameHeight:32 });
}

function create() {
    bucket = this.physics.add.staticSprite(400, 300, 'bucket');
    bucket.stored = 0;

    spawnWorker(this, 360, 320);
    spawnWorker(this, 440, 320);

    spawnRandomResource(this);
    spawnRandomResource(this);
    spawnRandomResource(this);

    this.input.on('pointerdown', (pointer, objects) => {
        if (!pointer.event.shiftKey) selectedWorkers = [];

        objects.forEach(obj => {
            if (obj.worker) {
                selectedWorkers.push(obj.worker);
            }
        });

        if (objects[0]?.resource) {
            selectedWorkers.forEach(w => w.setTarget(objects[0].resource));
        } else if (objects[0] === bucket) {
            selectedWorkers.forEach(w => w.setTarget(bucket));
        } else {
            selectedWorkers.forEach(w => w.moveTo(pointer.worldX, pointer.worldY));
        }
    });
}

function spawnWorker(scene, x, y) {
    const sprite = scene.physics.add.sprite(x, y, 'character', 0);
    sprite.worker = {
        sprite,
        inventory: 0,
        maxCarry: 20,
        state: 'IDLE',
        target: null,
        harvesting: null,
        timer: 0,
        selection: scene.add.image(x, y, 'select').setVisible(false),

        setTarget(target) {
            this.target = target;
            this.state = 'MOVING';
        },
        moveTo(x, y) {
            this.target = { x, y };
            this.state = 'MOVING';
        }
    };

    workers.push(sprite.worker);

    scene.physics.add.overlap(sprite, bucket, () => {
        if (sprite.worker.inventory > 0) {
            bucket.stored += sprite.worker.inventory;
            sprite.worker.inventory = 0;
            sprite.worker.state = 'IDLE';
        }
    });
}

function spawnRandomResource(scene) {
    const t = Phaser.Utils.Array.GetRandom(RESOURCE_TYPES);
    const sprite = scene.physics.add.staticSprite(
        Phaser.Math.Between(50,750),
        Phaser.Math.Between(50,550),
        t.key
    );

    const bar = scene.add.graphics();

    const resource = {
        sprite,
        value: t.value,
        max: t.value,
        interval: t.interval,
        timer: 0,
        bar
    };

    sprite.resource = resource;
    resources.push(resource);

    workers.forEach(w => {
        scene.physics.add.overlap(w.sprite, sprite, () => {
            if (w.inventory < w.maxCarry && resource.value > 0) {
                w.harvesting = resource;
                w.state = 'HARVESTING';
            }
        });
    });
}

function update(time, delta) {
    workers.forEach(w => {
        const s = w.sprite;

        w.selection.setPosition(s.x, s.y).setVisible(selectedWorkers.includes(w));

        if (w.state === 'MOVING' && w.target) {
            const tx = w.target.x ?? w.target.sprite?.x;
            const ty = w.target.y ?? w.target.sprite?.y;
            const d = Phaser.Math.Distance.Between(s.x, s.y, tx, ty);
            if (d > 6) {
                const a = Phaser.Math.Angle.Between(s.x, s.y, tx, ty);
                s.setVelocity(Math.cos(a)*100, Math.sin(a)*100);
            } else {
                s.setVelocity(0);
            }
        }

        if (w.state === 'HARVESTING' && w.harvesting) {
            const r = w.harvesting;
            r.timer += delta;
            drawBar(r);

            if (r.timer >= r.interval) {
                r.timer = 0;
                const amt = Math.min(5, r.value, w.maxCarry - w.inventory);
                r.value -= amt;
                w.inventory += amt;

                if (w.inventory >= w.maxCarry || r.value <= 0) {
                    w.harvesting = null;
                    w.setTarget(bucket);
                }

                if (r.value <= 0) destroyResource(r);
            }
        }
    });
}

function drawBar(r) {
    r.bar.clear();
    const p = r.timer / r.interval;
    r.bar.fillStyle(0x00ff00);
    r.bar.fillRect(r.sprite.x - 20, r.sprite.y - 30, 40 * p, 5);
}

function destroyResource(r) {
    r.bar.destroy();
    r.sprite.destroy();
    resources = resources.filter(x => x !== r);
    spawnRandomResource(r.sprite.scene);
}
</script>

</body>
</html>
