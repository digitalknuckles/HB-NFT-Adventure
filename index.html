<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RTS Worker Economy Prototype</title>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.85.2/dist/phaser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/easystarjs@0.4.4/bin/easystar-0.4.4.min.js"></script>

<style>
    body {
        margin: 0;
        background: #111;
        user-select: none;
    }
    canvas {
        display: block;
        margin: auto;
        border: 1px solid #333;
    }
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #0f0;
        font-family: monospace;
        font-size: 14px;
    }
</style>
</head>

<body oncontextmenu="return false;">
<div id="ui"></div>

<script>
/* =========================
   CONFIG
========================= */
const TILE_SIZE = 32;
const GRID_W = 25;
const GRID_H = 19;

const WORKER_COST = 100;
const WORKER_COOLDOWN = 5000;

const RESOURCE_TYPES = [
    { key: 'tree', value: 300, interval: 500 },
    { key: 'rock', value: 500, interval: 900 },
    { key: 'crystal', value: 800, interval: 1400 }
];

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: { default: 'arcade', arcade: { debug: false }},
    scene: { preload, create, update }
};

new Phaser.Game(config);

/* =========================
   GLOBAL STATE
========================= */
let workers = [];
let resources = [];
let buildings = [];
let selectedWorkers = [];
let bucket;

let dragStart = null;
let selectionGraphics;

let buyBtn, buyText;
let uiDiv = document.getElementById('ui');

let grid = [];
let easystar;

/* =========================
   PRELOAD
========================= */
function preload() {
    this.load.image('background', 'assets/background1.png');
    this.load.image('tree', 'assets/resource.png');
    this.load.image('rock', 'assets/rock.png');
    this.load.image('crystal', 'assets/crystal.png');
    this.load.image('bucket', 'assets/bucket.png');
    this.load.image('building', 'assets/building.png');
    this.load.image('select', 'assets/select.png');
    this.load.spritesheet('character','assets/character.png',{ frameWidth:32, frameHeight:32 });
}

/* =========================
   CREATE
========================= */
function create() {
    this.add.image(400, 300, 'background').setDepth(-10);

    buildGrid();
    setupPathfinding();

    bucket = this.physics.add.staticSprite(400, 300, 'bucket');
    bucket.storage = { tree: 0, rock: 0, crystal: 0 };

    spawnBuilding(this, 400, 150);
    spawnWorker(this, 360, 340);
    spawnWorker(this, 440, 340);

    spawnRandomResource(this);
    spawnRandomResource(this);
    spawnRandomResource(this);

    selectionGraphics = this.add.graphics().setDepth(1000);

    /* -------- INPUT -------- */

    this.input.on('pointerdown', pointer => {
        if (pointer.rightButtonDown()) return;
        dragStart = { x: pointer.worldX, y: pointer.worldY };
        selectedWorkers = [];
    });

    this.input.on('pointermove', pointer => {
        if (!dragStart) return;
        selectionGraphics.clear();
        selectionGraphics.lineStyle(1, 0x00ff00);
        selectionGraphics.strokeRect(
            dragStart.x,
            dragStart.y,
            pointer.worldX - dragStart.x,
            pointer.worldY - dragStart.y
        );
    });

    this.input.on('pointerup', pointer => {
        if (!dragStart || pointer.rightButtonDown()) return;

        const rect = new Phaser.Geom.Rectangle(
            Math.min(dragStart.x, pointer.worldX),
            Math.min(dragStart.y, pointer.worldY),
            Math.abs(pointer.worldX - dragStart.x),
            Math.abs(pointer.worldY - dragStart.y)
        );

        workers.forEach(w => {
            if (Phaser.Geom.Rectangle.Contains(rect, w.sprite.x, w.sprite.y)) {
                selectedWorkers.push(w);
            }
        });

        selectionGraphics.clear();
        dragStart = null;
    });

    /* RIGHT CLICK COMMAND */
    this.input.on('pointerup', pointer => {
        if (!pointer.rightButtonReleased()) return;

        issueFormationMove(pointer.worldX, pointer.worldY);
    });

    /* -------- BUY BUTTON -------- */
    buyBtn = this.add.rectangle(700, 50, 90, 30, 0x4444ff).setInteractive();
    buyText = this.add.text(655, 42, 'Buy Worker', { font: '14px Arial', fill: '#fff' });
    buyBtn.cooldown = 0;

    buyBtn.on('pointerdown', () => {
        if (buyBtn.cooldown > 0) return;
        if (bucket.storage.crystal < WORKER_COST) return;

        bucket.storage.crystal -= WORKER_COST;
        spawnWorker(this, buyBtn.x - 50, buyBtn.y + 60);
        buyBtn.cooldown = WORKER_COOLDOWN;
    });
}

/* =========================
   GRID & PATHFINDING
========================= */
function buildGrid() {
    grid = Array(GRID_H).fill().map(() => Array(GRID_W).fill(0));
}

function setupPathfinding() {
    easystar = new EasyStar.js();
    easystar.setGrid(grid);
    easystar.setAcceptableTiles([0]);
    easystar.enableDiagonals();
}

/* =========================
   SPAWNERS
========================= */
function spawnBuilding(scene, x, y) {
    const b = scene.physics.add.staticSprite(x, y, 'building');
    buildings.push(b);
    markGridBlocked(x, y);
}

function spawnWorker(scene, x, y) {
    const sprite = scene.physics.add.sprite(x, y, 'character', 0)
        .setInteractive();

    sprite.worker = {
        sprite,
        path: [],
        inventory: 0,
        maxCarry: 20,
        harvestingType: null,
        lastResource: null,
        state: 'IDLE',
        selection: scene.add.image(x, y, 'select').setVisible(false)
    };

    workers.push(sprite.worker);
    scene.physics.add.collider(sprite, buildings);

    scene.physics.add.overlap(sprite, bucket, () => {
        const w = sprite.worker;
        if (w.inventory > 0) {
            bucket.storage[w.harvestingType] += w.inventory;
            w.inventory = 0;
            if (w.lastResource?.value > 0) moveWorkerTo(w, w.lastResource.sprite.x, w.lastResource.sprite.y);
        }
    });
}

function spawnRandomResource(scene) {
    const t = Phaser.Utils.Array.GetRandom(RESOURCE_TYPES);
    const sprite = scene.physics.add.staticSprite(
        Phaser.Math.Between(80,720),
        Phaser.Math.Between(120,520),
        t.key
    );

    const bar = scene.add.graphics();
    const resource = { sprite, ...t, max: t.value, timer: 0, bar };
    sprite.resource = resource;
    resources.push(resource);
}

/* =========================
   MOVEMENT
========================= */
function issueFormationMove(x, y) {
    const cols = Math.ceil(Math.sqrt(selectedWorkers.length));
    selectedWorkers.forEach((w, i) => {
        const ox = (i % cols) * 24;
        const oy = Math.floor(i / cols) * 24;
        moveWorkerTo(w, x + ox, y + oy);
    });
}

function moveWorkerTo(worker, x, y) {
    const sx = Math.floor(worker.sprite.x / TILE_SIZE);
    const sy = Math.floor(worker.sprite.y / TILE_SIZE);
    const ex = Math.floor(x / TILE_SIZE);
    const ey = Math.floor(y / TILE_SIZE);

    easystar.findPath(sx, sy, ex, ey, path => {
        if (path) worker.path = path;
    });
    easystar.calculate();
}

/* =========================
   UPDATE
========================= */
function update(time, delta) {
    easystar.calculate();

    uiDiv.innerText =
        `TREE: ${bucket.storage.tree}\n` +
        `ROCK: ${bucket.storage.rock}\n` +
        `CRYSTAL: ${bucket.storage.crystal}`;

    workers.forEach(w => {
        const s = w.sprite;
        w.selection.setPosition(s.x, s.y).setVisible(selectedWorkers.includes(w));

        if (w.path.length > 0) {
            const node = w.path[0];
            const tx = node.x * TILE_SIZE + TILE_SIZE / 2;
            const ty = node.y * TILE_SIZE + TILE_SIZE / 2;
            const d = Phaser.Math.Distance.Between(s.x, s.y, tx, ty);

            if (d < 4) w.path.shift();
            else {
                const a = Phaser.Math.Angle.Between(s.x, s.y, tx, ty);
                s.setVelocity(Math.cos(a)*100, Math.sin(a)*100);
            }
        } else {
            s.setVelocity(0);
        }
    });

    if (buyBtn.cooldown > 0) buyBtn.cooldown -= delta;
}

/* =========================
   GRID HELPERS
========================= */
function markGridBlocked(x, y) {
    const gx = Math.floor(x / TILE_SIZE);
    const gy = Math.floor(y / TILE_SIZE);
    if (grid[gy] && grid[gy][gx] !== undefined) grid[gy][gx] = 1;
}
</script>
</body>
</html>
