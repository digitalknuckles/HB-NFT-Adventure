<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RTS Worker Economy MVP</title>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.85.2/dist/phaser.min.js"></script>

<style>
body {
    margin: 0;
    background: #111;
    user-select: none;
}
canvas {
    display: block;
    margin: auto;
    border: 1px solid #333;
}
#ui {
    position: absolute;
    top: 10px;
    left: 10px;
    color: #0f0;
    font-family: monospace;
    font-size: 14px;
    white-space: pre;
}
</style>
</head>

<body oncontextmenu="return false;">
<div id="ui"></div>

<script>
/* =========================
   CONFIG
========================= */
const MOVE_SPEED = 90;
const WORKER_COST = 100;
const WORKER_COOLDOWN = 3000;
const FORMATION_RADIUS = 26;

const RESOURCE_TYPES = [
    { key:'tree', value:300, interval:600 },
    { key:'rock', value:500, interval:900 },
    { key:'crystal', value:800, interval:1400 }
];

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: { default:'arcade' },
    scene: { preload, create, update }
};
new Phaser.Game(config);

/* =========================
   STATE
========================= */
let workers = [];
let resources = [];
let selectedWorkers = [];
let bucket;
let uiDiv = document.getElementById('ui');

let dragStart = null;
let dragGraphics;
let buyBtn;

/* =========================
   PRELOAD
========================= */
function preload() {
    this.load.image('background','assets/background1.png');
    this.load.image('tree','assets/resource.png');
    this.load.image('rock','assets/rock.png');
    this.load.image('crystal','assets/crystal.png');
    this.load.image('bucket','assets/bucket.png');
    this.load.spritesheet('character','assets/character.png',{
        frameWidth:32,
        frameHeight:32
    });
}

/* =========================
   CREATE
========================= */
function create() {
    this.add.image(400,300,'background').setDepth(-10);

    /* ---- ANIMATIONS ---- */
    const dirs = ['up','upR','right','downR','down','downL','left','upL'];
    for (let i=0;i<dirs.length;i++) {
        this.anims.create({
            key: dirs[i],
            frames: this.anims.generateFrameNumbers('character',{
                start:i*8,end:i*8+7
            }),
            frameRate:8,
            repeat:-1
        });
    }

    bucket = this.physics.add.staticSprite(400,300,'bucket');
    bucket.storage = { tree:0, rock:0, crystal:0 };

    spawnWorker(this,360,340);
    spawnWorker(this,440,340);

    spawnRandomResource(this);
    spawnRandomResource(this);
    spawnRandomResource(this);

    /* ---- BUY WORKER ---- */
    buyBtn = this.add.rectangle(700,50,90,30,0x4444ff).setInteractive();
    this.add.text(655,42,'Buy Worker',{font:'14px Arial',fill:'#fff'});
    buyBtn.cooldown = 0;

    buyBtn.on('pointerdown',()=>{
        if (buyBtn.cooldown>0) return;
        if (bucket.storage.crystal<WORKER_COST) return;
        bucket.storage.crystal-=WORKER_COST;
        spawnWorker(this,660,100);
        buyBtn.cooldown = WORKER_COOLDOWN;
    });

    /* ---- SELECTION ---- */
    dragGraphics = this.add.graphics();

    this.input.on('pointerdown',p=>{
        if (p.rightButtonDown()) return;
        dragStart = { x:p.worldX, y:p.worldY };
    });

    this.input.on('pointermove',p=>{
        if (!dragStart) return;
        dragGraphics.clear();
        dragGraphics.lineStyle(1,0x00ff00);
        dragGraphics.strokeRect(
            dragStart.x,
            dragStart.y,
            p.worldX-dragStart.x,
            p.worldY-dragStart.y
        );
    });

    this.input.on('pointerup',p=>{
        if (p.rightButtonDown()) return;

        dragGraphics.clear();
        selectedWorkers = [];

        const dist = Phaser.Math.Distance.Between(
            dragStart.x,dragStart.y,p.worldX,p.worldY
        );

        if (dist < 5) {
            workers.forEach(w=>{
                if (Phaser.Math.Distance.Between(
                    w.sprite.x,w.sprite.y,p.worldX,p.worldY
                ) < 16) selectedWorkers.push(w);
            });
        } else {
            const rect = new Phaser.Geom.Rectangle(
                Math.min(dragStart.x,p.worldX),
                Math.min(dragStart.y,p.worldY),
                Math.abs(p.worldX-dragStart.x),
                Math.abs(p.worldY-dragStart.y)
            );
            selectedWorkers = workers.filter(w =>
                Phaser.Geom.Rectangle.Contains(rect,w.sprite.x,w.sprite.y)
            );
        }

        dragStart = null;
    });

    /* ---- COMMAND ---- */
    this.input.on('pointerup',p=>{
        if (!p.rightButtonReleased()) return;
        if (selectedWorkers.length===0) return;

        const res = resources.find(r =>
            Phaser.Geom.Rectangle.Contains(r.sprite.getBounds(),p.worldX,p.worldY)
        );

        const center = res ? res.sprite : { x:p.worldX, y:p.worldY };
        const targets = getFormationTargets(center, selectedWorkers.length);

        selectedWorkers.forEach((w,i)=>{
            w.moveTarget = targets[i];
            if (res) {
                w.targetResource = res;
                w.state = 'MOVE_TO_RESOURCE';
            } else {
                w.state = 'MOVE';
            }
        });
    });
}

/* =========================
   WORKERS
========================= */
function spawnWorker(scene,x,y) {
    const s = scene.physics.add.sprite(x,y,'character');
    s.setFrame(35);

    const w = {
        sprite:s,
        state:'IDLE',
        inventory:0,
        maxCarry:20,
        harvestingType:null,
        targetResource:null,
        moveTarget:null,
        harvestTimer:0
    };
    workers.push(w);

    scene.physics.add.overlap(s,bucket,()=>{
        if (w.inventory>0) {
            bucket.storage[w.harvestingType]+=w.inventory;
            w.inventory=0;
            w.state = w.targetResource?.value>0 ? 'MOVE_TO_RESOURCE' : 'IDLE';
        }
    });
}

/* =========================
   RESOURCES
========================= */
function spawnRandomResource(scene) {
    const t = Phaser.Utils.Array.GetRandom(RESOURCE_TYPES);
    const s = scene.physics.add.staticSprite(
        Phaser.Math.Between(80,720),
        Phaser.Math.Between(120,520),
        t.key
    );
    resources.push({ ...t, sprite:s });
}

/* =========================
   UPDATE
========================= */
function update(time,delta) {
    uiDiv.textContent =
        `TREE: ${bucket.storage.tree}\n`+
        `ROCK: ${bucket.storage.rock}\n`+
        `CRYSTAL: ${bucket.storage.crystal}`;

    if (buyBtn.cooldown>0) buyBtn.cooldown-=delta;

    workers.forEach(w=>{
        const s=w.sprite;
        s.setTint(selectedWorkers.includes(w)?0x00ff00:0xffffff);

        if (w.state==='MOVE' && w.moveTarget)
            moveTowards(w,w.moveTarget,()=>w.state='IDLE');

        if (w.state==='MOVE_TO_RESOURCE' && w.moveTarget)
            moveTowards(w,w.moveTarget,()=>{
                w.harvestingType=w.targetResource.key;
                w.state='HARVESTING';
            });

        if (w.state==='HARVESTING') {
            w.harvestTimer+=delta;
            if (w.harvestTimer>=w.targetResource.interval) {
                w.harvestTimer=0;
                const amt=Math.min(5,w.targetResource.value,w.maxCarry-w.inventory);
                w.targetResource.value-=amt;
                w.inventory+=amt;
                if (w.inventory>=w.maxCarry||w.targetResource.value<=0)
                    w.state='MOVE_TO_BUCKET';
            }
        }

        if (w.state==='MOVE_TO_BUCKET')
            moveTowards(w,bucket,()=>w.state='IDLE');
    });
}

/* =========================
   FORMATION
========================= */
function getFormationTargets(center,count) {
    const out=[];
    for (let i=0;i<count;i++) {
        const a=(Math.PI*2/count)*i;
        out.push({
            x:center.x+Math.cos(a)*FORMATION_RADIUS,
            y:center.y+Math.sin(a)*FORMATION_RADIUS
        });
    }
    return out;
}

/* =========================
   MOVEMENT + ANIMATION
========================= */
function moveTowards(w,t,onArrive) {
    if (!t) return;

    const s=w.sprite;
    const dx=t.x-s.x, dy=t.y-s.y;
    const d=Math.hypot(dx,dy);

    if (d<5) {
        s.setVelocity(0);
        s.anims.stop();
        s.setFrame(35);
        onArrive?.();
        return;
    }

    s.setVelocity(dx/d*MOVE_SPEED,dy/d*MOVE_SPEED);

    const a=Phaser.Math.RadToDeg(Math.atan2(dy,dx));
    let dir='down';
    if (a<-157||a>157) dir='left';
    else if (a<-112) dir='upL';
    else if (a<-67) dir='up';
    else if (a<-22) dir='upR';
    else if (a<22) dir='right';
    else if (a<67) dir='downR';
    else if (a<112) dir='down';
    else dir='downL';

    if (s.anims.currentAnim?.key!==dir) s.play(dir);
}
</script>
</body>
</html>
