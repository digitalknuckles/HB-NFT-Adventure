<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RTS Worker Economy Prototype</title>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.85.2/dist/phaser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/easystarjs@0.4.4/bin/easystar-0.4.4.min.js"></script>

<style>
    body {
        margin: 0;
        background: #111;
        user-select: none;
    }
    canvas {
        display: block;
        margin: auto;
        border: 1px solid #333;
    }
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #0f0;
        font-family: monospace;
        font-size: 14px;
        white-space: pre-line;
    }
</style>
</head>

<body oncontextmenu="return false;">
<div id="ui"></div>

<script>
/* =========================
   CONFIG
========================= */
const TILE_SIZE = 32;
const GRID_W = 25;
const GRID_H = 19;

const WORKER_COST = 100;
const WORKER_COOLDOWN = 5000;

const RESOURCE_TYPES = [
    { key: 'tree', value: 300, interval: 500 },
    { key: 'rock', value: 500, interval: 900 },
    { key: 'crystal', value: 800, interval: 1400 }
];

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: { default: 'arcade', arcade: { debug: false }},
    scene: { preload, create, update }
};

new Phaser.Game(config);

/* =========================
   GLOBAL STATE
========================= */
let workers = [];
let resources = [];
let buildings = [];
let selectedWorkers = [];
let bucket;

let dragStart = null;
let selectionGraphics;

let buyBtn, buyText;
let uiDiv = document.getElementById('ui');

let grid = [];
let easystar;

/* =========================
   PRELOAD
========================= */
function preload() {
    this.load.image('background', 'assets/background1.png');
    this.load.image('tree', 'assets/resource.png');
    this.load.image('rock', 'assets/rock.png');
    this.load.image('crystal', 'assets/crystal.png');
    this.load.image('bucket', 'assets/bucket.png');
    this.load.image('building', 'assets/building.png');
    this.load.image('select', 'assets/select.png');
    this.load.spritesheet('character','assets/character.png',{ frameWidth:32, frameHeight:32 });
}

/* =========================
   CREATE
========================= */
function create() {
    this.add.image(400, 300, 'background').setDepth(-10);

    buildGrid();
    setupPathfinding();

    bucket = this.physics.add.staticSprite(400, 300, 'bucket');
    bucket.storage = { tree: 0, rock: 0, crystal: 0 };

    spawnBuilding(this, 400, 150);
    spawnWorker(this, 360, 340);
    spawnWorker(this, 440, 340);

    spawnRandomResource(this);
    spawnRandomResource(this);
    spawnRandomResource(this);

    selectionGraphics = this.add.graphics().setDepth(1000);

    /* -------- INPUT -------- */

    // LEFT CLICK SELECT / DRAG
    this.input.on('pointerdown', pointer => {
        if (pointer.rightButtonDown()) return;
        dragStart = { x: pointer.worldX, y: pointer.worldY };
        selectedWorkers = [];
    });

    this.input.on('pointermove', pointer => {
        if (!dragStart) return;
        selectionGraphics.clear();
        selectionGraphics.lineStyle(1, 0x00ff00);
        selectionGraphics.strokeRect(
            dragStart.x,
            dragStart.y,
            pointer.worldX - dragStart.x,
            pointer.worldY - dragStart.y
        );
    });

    this.input.on('pointerup', pointer => {
        if (!dragStart || pointer.rightButtonDown()) return;

        const rect = new Phaser.Geom.Rectangle(
            Math.min(dragStart.x, pointer.worldX),
            Math.min(dragStart.y, pointer.worldY),
            Math.abs(pointer.worldX - dragStart.x),
            Math.abs(pointer.worldY - dragStart.y)
        );

        workers.forEach(w => {
            if (Phaser.Geom.Rectangle.Contains(rect, w.sprite.x, w.sprite.y)) {
                selectedWorkers.push(w);
            }
        });

        selectionGraphics.clear();
        dragStart = null;
    });

    // RIGHT CLICK COMMAND (MOVE or HARVEST)
    this.input.on('pointerup', pointer => {
        if (!pointer.rightButtonReleased()) return;

        const objects = this.input.hitTestPointer(pointer);

        // Harvest resource
        if (objects.length && objects[0].resource) {
            commandHarvest(objects[0].resource);
        } else {
            // Move formation
            issueFormationMove(pointer.worldX, pointer.worldY);
        }
    });

    /* -------- BUY BUTTON -------- */
    buyBtn = this.add.rectangle(700, 50, 90, 30, 0x4444ff).setInteractive();
    buyText = this.add.text(655, 42, 'Buy Worker', { font: '14px Arial', fill: '#fff' });
    buyBtn.cooldown = 0;

    buyBtn.on('pointerdown', () => {
        if (buyBtn.cooldown > 0) return;
        if (bucket.storage.crystal < WORKER_COST) return;

        bucket.storage.crystal -= WORKER_COST;
        spawnWorker(this, buyBtn.x - 50, buyBtn.y + 60);
        buyBtn.cooldown = WORKER_COOLDOWN;
    });
}

/* =========================
   GRID & PATHFINDING
========================= */
function buildGrid() {
    grid = Array(GRID_H).fill().map(() => Array(GRID_W).fill(0));
}

function setupPathfinding() {
    easystar = new EasyStar.js();
    easystar.setGrid(grid);
    easystar.setAcceptableTiles([0]);
    easystar.enableDiagonals();
}

/* =========================
   SPAWNERS
========================= */
function spawnBuilding(scene, x, y) {
    const b = scene.physics.add.staticSprite(x, y, 'building');
    buildings.push(b);
    markGridBlocked(x, y);
}

function spawnWorker(scene, x, y) {
    const sprite = scene.physics.add.sprite(x, y, 'character', 0).setInteractive();

    sprite.worker = {
        sprite,
        path: [],
        inventory: 0,
        maxCarry: 20,
        harvesting: null,
        harvestingType: null,
        lastResource: null,
        state: 'IDLE',
        selection: scene.add.image(x, y, 'select').setVisible(false)
    };

    workers.push(sprite.worker);
    scene.physics.add.collider(sprite, buildings);
    scene.physics.add.overlap(sprite, bucket, () => {
        const w = sprite.worker;
        if (w.inventory > 0) {
            bucket.storage[w.harvestingType] += w.inventory;
            w.inventory = 0;
            w.harvestingType = null;
            if (w.lastResource?.value > 0) moveWorkerTo(w, w.lastResource.sprite.x, w.lastResource.sprite.y);
        }
    });
}

function spawnRandomResource(scene) {
    const t = Phaser.Utils.Array.GetRandom(RESOURCE_TYPES);
    const sprite = scene.physics.add.staticSprite(
        Phaser.Math.Between(80,720),
        Phaser.Math.Between(120,520),
        t.key
    );

    const bar = scene.add.graphics();
    const resource = { sprite, type: t.key, value: t.value, max: t.value, interval: t.interval, timer: 0, bar };
    sprite.resource = resource;
    resources.push(resource);
}

/* =========================
   MOVEMENT & FORMATION
========================= */
function issueFormationMove(x, y) {
    const cols = Math.ceil(Math.sqrt(selectedWorkers.length));
    selectedWorkers.forEach((w, i) => {
        const ox = (i % cols) * 24;
        const oy = Math.floor(i / cols) * 24;
        moveWorkerTo(w, x + ox, y + oy);
        w.state = 'MOVING';
        w.harvesting = null;
    });
}

function moveWorkerTo(worker, x, y) {
    const sx = Math.floor(worker.sprite.x / TILE_SIZE);
    const sy = Math.floor(worker.sprite.y / TILE_SIZE);
    const ex = Math.floor(x / TILE_SIZE);
    const ey = Math.floor(y / TILE_SIZE);

    easystar.findPath(sx, sy, ex, ey, path => {
        if (path) worker.path = path;
    });
    easystar.calculate();
}

/* =========================
   HARVEST COMMAND
========================= */
function commandHarvest(resource) {
    selectedWorkers.forEach(w => {
        w.harvesting = resource;
        w.harvestingType = resource.type;
        w.lastResource = resource;
        moveWorkerTo(w, resource.sprite.x, resource.sprite.y);
        w.state = 'MOVING';
    });
}

/* =========================
   UPDATE LOOP
========================= */
function update(time, delta) {
    easystar.calculate();

    // Update UI
    uiDiv.innerText =
        `TREE: ${bucket.storage.tree}\n` +
        `ROCK: ${bucket.storage.rock}\n` +
        `CRYSTAL: ${bucket.storage.crystal}`;

    // Buy button cooldown
    if (buyBtn.cooldown > 0) buyBtn.cooldown -= delta;

    workers.forEach(w => {
        const s = w.sprite;
        w.selection.setPosition(s.x, s.y).setVisible(selectedWorkers.includes(w));

        // MOVE ALONG PATH
        if (w.path.length > 0) {
            const node = w.path[0];
            const tx = node.x * TILE_SIZE + TILE_SIZE/2;
            const ty = node.y * TILE_SIZE + TILE_SIZE/2;
            const d = Phaser.Math.Distance.Between(s.x, s.y, tx, ty);
            if (d < 4) w.path.shift();
            else {
                const a = Phaser.Math.Angle.Between(s.x, s.y, tx, ty);
                s.setVelocity(Math.cos(a)*100, Math.sin(a)*100);
            }
        } else {
            s.setVelocity(0);

            // START HARVESTING IF AT RESOURCE
            if (w.harvesting && w.state !== 'HARVESTING') {
                const r = w.harvesting;
                if (r.value > 0 && Phaser.Math.Distance.Between(s.x, s.y, r.sprite.x, r.sprite.y) < 20) {
                    w.state = 'HARVESTING';
                    r.timer = 0;
                }
            }
        }

        // HARVEST LOGIC
        if (w.state === 'HARVESTING' && w.harvesting) {
            const r = w.harvesting;
            r.timer += delta;

            // draw bar
            r.bar.clear();
            const p = r.timer / r.interval;
            r.bar.fillStyle(0x00ff00);
            r.bar.fillRect(r.sprite.x-20, r.sprite.y-30, 40*p, 5);

            if (r.timer >= r.interval) {
                r.timer = 0;
                const amt = Math.min(5, r.value, w.maxCarry - w.inventory);
                r.value -= amt;
                w.inventory += amt;
                r.sprite.setScale(r.value/r.max);

                if (w.inventory >= w.maxCarry || r.value <= 0) {
                    w.state = 'MOVING';
                    moveWorkerTo(w, bucket.x, bucket.y);
                }

                if (r.value <= 0) {
                    r.bar.destroy();
                    r.sprite.destroy();
                    resources = resources.filter(x=>x!==r);
                    spawnRandomResource(w.sprite.scene);
                }
            }
        }
    });
}

/* =========================
   GRID HELPERS
========================= */
function markGridBlocked(x, y) {
    const gx = Math.floor(x / TILE_SIZE);
    const gy = Math.floor(y / TILE_SIZE);
    if (grid[gy] && grid[gy][gx] !== undefined) grid[gy][gx] = 1;
}
</script>
</body>
</html>
