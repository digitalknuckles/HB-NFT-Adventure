<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RTS Worker Economy MVP</title>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.85.2/dist/phaser.min.js"></script>

<style>
    body {
        margin: 0;
        background: #111;
        user-select: none;
    }
    canvas {
        display: block;
        margin: auto;
        border: 1px solid #333;
    }
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #0f0;
        font-family: monospace;
        font-size: 14px;
        white-space: pre;
    }
</style>
</head>

<body oncontextmenu="return false;">
<div id="ui"></div>

<script>
/* =========================
   CONFIG
========================= */
const MOVE_SPEED = 90;
const WORKER_COST = 100;
const WORKER_COOLDOWN = 5000;

const RESOURCE_TYPES = [
    { key: 'tree', value: 300, interval: 600 },
    { key: 'rock', value: 500, interval: 900 },
    { key: 'crystal', value: 800, interval: 1400 }
];

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: { default: 'arcade' },
    scene: { preload, create, update }
};

new Phaser.Game(config);

/* =========================
   GLOBAL STATE
========================= */
let workers = [];
let resources = [];
let selectedWorkers = [];
let bucket;
let dragStart = null;
let selectionGraphics;
let uiDiv = document.getElementById('ui');
let buyBtn, buyText;

/* =========================
   PRELOAD
========================= */
function preload() {
    this.load.image('background', 'assets/background1.png');
    this.load.image('tree', 'assets/resource.png');
    this.load.image('rock', 'assets/rock.png');
    this.load.image('crystal', 'assets/crystal.png');
    this.load.image('bucket', 'assets/bucket.png');
    this.load.spritesheet('character','assets/character.png',{
        frameWidth: 32,
        frameHeight: 32
    });
}

/* =========================
   CREATE
========================= */
function create() {
    this.add.image(400, 300, 'background').setDepth(-10);

    /* --- ANIMATIONS (FIXED) --- */
    this.anims.create({
        key: 'worker-idle',
        frames: this.anims.generateFrameNumbers('character', {
            start: 0,
            end: 7
        }),
        frameRate: 4,
        repeat: -1
    });

    this.anims.create({
        key: 'worker-walk',
        frames: this.anims.generateFrameNumbers('character', {
            start: 8,
            end: 15
        }),
        frameRate: 10,
        repeat: -1
    });

    bucket = this.physics.add.staticSprite(400, 300, 'bucket');
    bucket.storage = { tree: 0, rock: 0, crystal: 0 };

    spawnWorker(this, 360, 340);
    spawnWorker(this, 440, 340);

    spawnRandomResource(this);
    spawnRandomResource(this);
    spawnRandomResource(this);

    selectionGraphics = this.add.graphics();

    /* ---- SELECTION ---- */
    this.input.on('pointerdown', p => {
        if (p.rightButtonDown()) return;
        dragStart = { x: p.worldX, y: p.worldY };
        selectedWorkers = [];
    });

    this.input.on('pointermove', p => {
        if (!dragStart) return;
        selectionGraphics.clear();
        selectionGraphics.lineStyle(1, 0x00ff00);
        selectionGraphics.strokeRect(
            dragStart.x,
            dragStart.y,
            p.worldX - dragStart.x,
            p.worldY - dragStart.y
        );
    });

    this.input.on('pointerup', p => {
        if (p.rightButtonDown() || !dragStart) return;

        const rect = new Phaser.Geom.Rectangle(
            Math.min(dragStart.x, p.worldX),
            Math.min(dragStart.y, p.worldY),
            Math.abs(p.worldX - dragStart.x),
            Math.abs(p.worldY - dragStart.y)
        );

        workers.forEach(w => {
            if (Phaser.Geom.Rectangle.Contains(rect, w.sprite.x, w.sprite.y))
                selectedWorkers.push(w);
        });

        dragStart = null;
        selectionGraphics.clear();
    });

    /* ---- COMMAND ---- */
    this.input.on('pointerup', p => {
        if (!p.rightButtonReleased()) return;

        selectedWorkers.forEach(w => {
            const res = resources.find(r =>
                Phaser.Geom.Rectangle.Contains(r.sprite.getBounds(), p.worldX, p.worldY)
            );

            if (res) {
                w.targetResource = res;
                w.state = 'MOVE_TO_RESOURCE';
            } else {
                w.moveTarget = { x: p.worldX, y: p.worldY };
                w.state = 'MOVE';
            }
        });
    });
}

/* =========================
   SPAWNERS
========================= */
function spawnWorker(scene, x, y) {
    const sprite = scene.physics.add.sprite(x, y, 'character');
    sprite.play('worker-idle');

    const worker = {
        sprite,
        state: 'IDLE',
        inventory: 0,
        maxCarry: 20,
        harvestingType: null,
        targetResource: null,
        moveTarget: null,
        harvestTimer: 0
    };

    workers.push(worker);

    scene.physics.add.overlap(sprite, bucket, () => {
        if (worker.inventory > 0) {
            bucket.storage[worker.harvestingType] += worker.inventory;
            worker.inventory = 0;

            if (worker.targetResource?.value > 0)
                worker.state = 'MOVE_TO_RESOURCE';
            else
                worker.state = 'IDLE';
        }
    });
}

function spawnRandomResource(scene) {
    const t = Phaser.Utils.Array.GetRandom(RESOURCE_TYPES);
    const sprite = scene.physics.add.staticSprite(
        Phaser.Math.Between(80,720),
        Phaser.Math.Between(120,520),
        t.key
    );

    const bar = scene.add.graphics();
    resources.push({ ...t, sprite, bar, max: t.value, timer: 0 });
}

/* =========================
   UPDATE
========================= */
function update(time, delta) {
    uiDiv.textContent =
        `TREE: ${bucket.storage.tree}\n` +
        `ROCK: ${bucket.storage.rock}\n` +
        `CRYSTAL: ${bucket.storage.crystal}`;

    workers.forEach(w => {
        const s = w.sprite;

        s.setTint(selectedWorkers.includes(w) ? 0x00ff00 : 0xffffff);

        if (w.state === 'MOVE')
            moveTowards(s, w.moveTarget, () => w.state='IDLE');

        if (w.state === 'MOVE_TO_RESOURCE')
            moveTowards(s, w.targetResource.sprite, () => {
                w.harvestingType = w.targetResource.key;
                w.state = 'HARVESTING';
            });

        if (w.state === 'HARVESTING') {
            const r = w.targetResource;
            w.harvestTimer += delta;

            if (w.harvestTimer >= r.interval) {
                w.harvestTimer = 0;
                const amt = Math.min(5, r.value, w.maxCarry - w.inventory);
                r.value -= amt;
                w.inventory += amt;

                if (w.inventory >= w.maxCarry || r.value <= 0)
                    w.state = 'MOVE_TO_BUCKET';
            }
        }

        if (w.state === 'MOVE_TO_BUCKET')
            moveTowards(s, bucket, () => w.state='IDLE');
    });
}

/* =========================
   HELPERS
========================= */
function moveTowards(sprite, target, onArrive) {
    const dx = target.x - sprite.x;
    const dy = target.y - sprite.y;
    const d = Math.hypot(dx, dy);

    if (d < 6) {
        sprite.setVelocity(0);
        sprite.play('worker-idle', true);
        onArrive?.();
    } else {
        sprite.setVelocity(dx/d * MOVE_SPEED, dy/d * MOVE_SPEED);
        sprite.play('worker-walk', true);
        sprite.setFlipX(dx < 0);
    }
}
</script>
</body>
</html>
